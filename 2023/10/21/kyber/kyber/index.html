<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="linux内核块层有kyber、mq-deadline以及bfq三个针对multi queue设计的调度器，这篇文章主要是讲解kyber调度器的原理和源码，分析的内核版本是4.20。"/><meta name="keywords" content="block, Cahir's blog" /><link rel="alternate" href="/default" title="Cahir's blog" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.2" />
<link rel="canonical" href="http://example.com/2023/10/21/kyber/kyber/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.2" />

<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>kyber调度器原理及源码分析 - Cahir's blog</title>
  <meta name="generator" content="Hexo 5.4.2"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Cahir's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Cahir's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">kyber调度器原理及源码分析
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2023-10-21
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kyber-queue-data"><span class="toc-text">kyber_queue_data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kyber-hctx-data"><span class="toc-text">kyber_hctx_data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96kyber"><span class="toc-text">初始化kyber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96kyber-queue-data"><span class="toc-text">初始化kyber_queue_data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96kyber-hctx-data"><span class="toc-text">初始化kyber_hctx_data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bio%E5%90%88%E5%B9%B6%E5%85%A5kyber"><span class="toc-text">bio合并入kyber</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#request%E6%8F%92%E5%85%A5%E5%88%B0kyber"><span class="toc-text">request插入到kyber</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kyber%E5%88%86%E5%8F%91request"><span class="toc-text">kyber分发request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#request%E5%AE%8C%E6%88%90"><span class="toc-text">request完成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%97%B6%E5%BB%B6%E7%BB%9F%E8%AE%A1%E8%B0%83%E6%95%B4token%E6%95%B0"><span class="toc-text">根据时延统计调整token数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kyber%E9%80%80%E5%87%BA"><span class="toc-text">kyber退出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><p>linux内核块层有kyber、mq-deadline以及bfq三个针对multi queue设计的调度器，这篇文章主要是讲解kyber调度器的原理和源码，分析的内核版本是4.20。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们知道当Block层不使用任何的调度器的时候，调度队列是按照每个cpu核一个软队列，一定数量的硬队列，并将软队列和硬队列建立一定的映射关系“map”来调度IO的，通过当前的cpu_id能找到per_cpu的软队列，在软队列里面完成插入、合并等动作，然后通过map[cpu_id]找到其映射的硬队列，从而将IO分发到硬队列，最后硬队列将IO下发到驱动层，由驱动层将IO通过某个总线(PCIe、FC、RoCE等)发送到设备层。</p>
<p>当kyber调度器启用时，kyber舍弃软队列，创建read、write、discard、other四个队列将IO分类处理。kyber不是消耗光了某个队列再去分发下一个队列，而是消耗到一定的个数就切换到下一个队列，从而防止后面的队列被饿死，这个个数分别是16、8、1、1，也就是分发了16个读IO之后去分发写，分发了8个写之后再分发一个discard，最后分发一个other的IO，以此类推循环。</p>
<p>kyber是怎么找到应该往哪个硬队列分发呢？</p>
<p>答案是根据当前cpu_id找到软队列，然后通过记录在软队列里面的“该软队列在其对应的硬队列里面的所有跟这个硬队列关联的软队列的编号”就能找到其对应的硬队列。前面这句话有点绕，解释一下，系统内最好的情况下是软队列个数等于硬队列个数，这样软队列和硬队列就能一一对应，但是通常情况下受限于实际的块设备的处理能力，硬队列个数往往小于软队列的个数，因此需要将多个软队列跟一个硬队列映射绑定，形成多对一的关系，在硬队列里面有个数组<strong>struct blk_mq_ctx    ctxs</strong>就记录了该硬队列对应的所有软队列，其下标则存在于软队列结构体里面<strong>unsigned int  index_hw</strong>，详细可参考源码函数blk_mq_map_swqueue()。</p>
<p>下面说说kyber的这个“分发队列”，让人反直觉的是request（block层io结构体）不是直接insert到分发队列的，而是先insert到“暂存队列”（我们暂时给它这么个名字，后面有详细的结构体），在暂存队列IO被合并、分类，然后当分发队列为空而需要分发一个IO的时候就会将暂存队列的IO都挂到分发队列上，然后选择一个IO分发到硬队列。</p>
<img src="kyber.jpg">

<p>​                                                                                        图中我们假设cpu0、cpu1对应这个硬队列。</p>
<p>挂入分发队列的IO个数理论是无限的，虽然每轮只会分发固定数量的IO，但是一轮循环完毕就会立马进行下一轮循环，而此时前面分发的IO可能都还没有回来，就没有起到控制的作用了。kyber针对read、write、discard、other分别设置了总的token数目，分别为256、128、64、16，当要分发一个IO到硬队列的时候，先得拿到这个token，然后才能分发，如果当前token已经耗光，也就是说底层硬处理地慢而上层下发地快了，就要将当前的分发队列挂起，在下层的某个IO执行完毕回来后看这个IO的类型的分发队列是否挂起的，有则将其唤醒去分发IO。</p>
<p>此外kyber还会统计IO的时延，并且针对read、write、discard设置了时延参考值，分别为2000000nsec、10000000nsec、5000000nsec。kyber通过将统计的时延与参考值进行对比，动态地调整每种类型IO的token数目，以求公平。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="kyber-queue-data"><a href="#kyber-queue-data" class="headerlink" title="kyber_queue_data"></a>kyber_queue_data</h3><p>kyber_queue_data是kyber的主要数据结构之一，当将块设备的调度器切换到kyber时就会生成这样的结构体存放在elevator_queue的elevator_data中，通过request_queue可以找到elevator_queue，自然就能找到kyber_queue_data。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span>;</span> <span class="comment">// 块设备对应一个request_queue，也就对应一个kyber_queue_data</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Each scheduling domain has a limited number of in-flight requests</span></span><br><span class="line"><span class="comment">	 * device-wide, limited by these tokens.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 每种队列的token占用情况，分发IO时从这里申请</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbitmap_queue</span> <span class="title">domain_tokens</span>[<span class="title">KYBER_NUM_DOMAINS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Async request percentage, converted to per-word depth for</span></span><br><span class="line"><span class="comment">	 * sbitmap_get_shallow().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 用该值限制异步请求的带宽，防止同步请求被饿死</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> async_depth;</span><br><span class="line">	<span class="comment">// per_cpu地统计时延信息，IO完成时就会统计时延到这里</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_cpu_latency</span> __<span class="title">percpu</span> *<span class="title">cpu_latency</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timer for stats aggregation and adjusting domain tokens. */</span></span><br><span class="line">    <span class="comment">// 有一个timer，每隔一段时间统计一下时延情况，根据统计情况调整token数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">	<span class="comment">// 上面的timer每隔一段时间会将per_cpu统计的时延加到这里面计算新的token数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> latency_buckets[KYBER_OTHER][<span class="number">2</span>][KYBER_LATENCY_BUCKETS];</span><br><span class="line">	<span class="comment">// 记录上一次调整token的时间</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> latency_timeout[KYBER_OTHER];</span><br><span class="line">	<span class="comment">// 记录上一次timer得到的时延好坏结果，如果下一次timer的时候时延的样本数量不够则用这一次的</span></span><br><span class="line">    <span class="comment">// 下一次timer如果采用了这一次计算的延时好坏结果，则将其值置为-1，不再使用，只使用一次</span></span><br><span class="line">	<span class="type">int</span> domain_p99[KYBER_OTHER];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Target latencies in nanoseconds. */</span></span><br><span class="line">    <span class="comment">// 每种IO类型的时延参考值</span></span><br><span class="line">	u64 latency_targets[KYBER_OTHER];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="kyber-hctx-data"><a href="#kyber-hctx-data" class="headerlink" title="kyber_hctx_data"></a>kyber_hctx_data</h3><p>存放于硬队列blk_mq_hw_ctx的sched_data字段，包含了原理一章中提到的“暂存队列”和“分发队列”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kyber_hctx_data</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rqs</span>[<span class="title">KYBER_NUM_DOMAINS</span>];</span> <span class="comment">// 分发队列，IO从这个队列提交到硬队列</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cur_domain; <span class="comment">// 当前分发的是read、write、discard还是other</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batching; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_ctx_queue</span> *<span class="title">kcqs</span>;</span> <span class="comment">// 暂存队列，硬队列对应的软队列有多少个就有多少个暂存队列</span></span><br><span class="line">    <span class="comment">// kcq_map用于表示暂存队列上是否有IO</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbitmap</span> <span class="title">kcq_map</span>[<span class="title">KYBER_NUM_DOMAINS</span>];</span></span><br><span class="line"> 	<span class="comment">// 当token耗光的时候，分发队列进入wait状态，等待回来的io释放token将之唤醒，以下是这个流程需要用到的结构</span></span><br><span class="line">	<span class="type">wait_queue_entry_t</span> domain_wait[KYBER_NUM_DOMAINS];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbq_wait_state</span> *<span class="title">domain_ws</span>[<span class="title">KYBER_NUM_DOMAINS</span>];</span></span><br><span class="line">	<span class="type">atomic_t</span> wait_index[KYBER_NUM_DOMAINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kyber_ctx_queue</span> &#123;</span> <span class="comment">// 暂存队列，由此可见一个暂存队列就有4个种类的队列</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Used to ensure operations on rq_list and kcq_map to be an atmoic one.</span></span><br><span class="line"><span class="comment">	 * Also protect the rqs on rq_list when merge.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rq_list</span>[<span class="title">KYBER_NUM_DOMAINS</span>];</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="初始化kyber"><a href="#初始化kyber" class="headerlink" title="初始化kyber"></a>初始化kyber</h3><p>当kyber模块注册时回调用kyber_init()函数注册kyber给elevator，包括kyber的名字、属性、debugfs相关信息、owner以及最重要的hook。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kyber_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> elv_register(&amp;kyber_sched);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">elevator_type</span> <span class="title">kyber_sched</span> =</span> &#123; <span class="comment">// 这些hook在后续的章节中会一一讲到</span></span><br><span class="line">	.ops.mq = &#123;</span><br><span class="line">		.init_sched = kyber_init_sched,</span><br><span class="line">		.exit_sched = kyber_exit_sched,</span><br><span class="line">		.init_hctx = kyber_init_hctx,</span><br><span class="line">		.exit_hctx = kyber_exit_hctx, <span class="comment">// 以上是初始化和释放kyber内部结构体的函数</span></span><br><span class="line">		.limit_depth = kyber_limit_depth, <span class="comment">// 限制request队列的深度</span></span><br><span class="line">		.bio_merge = kyber_bio_merge, <span class="comment">// 将bio合并到kyber</span></span><br><span class="line">		.prepare_request = kyber_prepare_request, <span class="comment">// 初始化request时调用</span></span><br><span class="line">		.insert_requests = kyber_insert_requests, <span class="comment">// 将request插入到kyber</span></span><br><span class="line">		.finish_request = kyber_finish_request, <span class="comment">// 释放request时调用</span></span><br><span class="line">		.requeue_request = kyber_finish_request, <span class="comment">// 将request重新入队时调用</span></span><br><span class="line">		.completed_request = kyber_completed_request, <span class="comment">// request完成时调用</span></span><br><span class="line">		.dispatch_request = kyber_dispatch_request, <span class="comment">// 分发request</span></span><br><span class="line">		.has_work = kyber_has_work, <span class="comment">// kyber是否有未分发的request</span></span><br><span class="line">	&#125;,</span><br><span class="line">	.uses_mq = <span class="literal">true</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEBUG_FS</span></span><br><span class="line">	.queue_debugfs_attrs = kyber_queue_debugfs_attrs,</span><br><span class="line">	.hctx_debugfs_attrs = kyber_hctx_debugfs_attrs,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.elevator_attrs = kyber_sched_attrs,</span><br><span class="line">	.elevator_name = <span class="string">&quot;kyber&quot;</span>,</span><br><span class="line">	.elevator_owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="初始化kyber-queue-data"><a href="#初始化kyber-queue-data" class="headerlink" title="初始化kyber_queue_data"></a>初始化kyber_queue_data</h3><p>当块设备的调度器被设置成kyber时会调用kyber_init_sched()函数初始化kyber_queue_data，将kyber_queue_data与request_queue绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kyber_init_sched</span><span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> elevator_type *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">eq</span>;</span></span><br><span class="line"></span><br><span class="line">	eq = elevator_alloc(q, e); <span class="comment">// 申请电梯队列结构，request可通过该结构访问到kyber_queue_data</span></span><br><span class="line">	<span class="keyword">if</span> (!eq)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	kqd = kyber_queue_data_alloc(q); <span class="comment">// 申请kyber_queue_data并初始化</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(kqd)) &#123;</span><br><span class="line">		kobject_put(&amp;eq-&gt;kobj);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(kqd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	blk_stat_enable_accounting(q);</span><br><span class="line"></span><br><span class="line">	eq-&gt;elevator_data = kqd; <span class="comment">// 将kyber_queue_data和elevator_queue绑定</span></span><br><span class="line">	q-&gt;elevator = eq; <span class="comment">// 将elevator_queue和request_queue绑定</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kyber_queue_data_alloc函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kyber_queue_data *<span class="title function_">kyber_queue_data_alloc</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shift;</span><br><span class="line">	<span class="type">int</span> ret = -ENOMEM;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	kqd = kzalloc_node(<span class="keyword">sizeof</span>(*kqd), GFP_KERNEL, q-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!kqd)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	kqd-&gt;q = q; <span class="comment">// 将kyber_queue_data与request_queue绑定</span></span><br><span class="line">	<span class="comment">// 初始化per_cpu的时延统计</span></span><br><span class="line">	kqd-&gt;cpu_latency = alloc_percpu_gfp(<span class="keyword">struct</span> kyber_cpu_latency,</span><br><span class="line">					    GFP_KERNEL | __GFP_ZERO);</span><br><span class="line">	<span class="keyword">if</span> (!kqd-&gt;cpu_latency)</span><br><span class="line">		<span class="keyword">goto</span> err_kqd;</span><br><span class="line">	<span class="comment">// 初始化时延统计timer</span></span><br><span class="line">    <span class="comment">// kyber_timer_fn会将所有per_cpu的时延统计加起来，然后通过一定的算法调整每个类型队列的    token数目</span></span><br><span class="line">	timer_setup(&amp;kqd-&gt;timer, kyber_timer_fn, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 初始化每种队列的token数，kyber_depth全局变量显示为256、128、64、16</span></span><br><span class="line">    <span class="comment">// token的申请、挂起、释放是通过sbitmap实现的</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;</span><br><span class="line">		WARN_ON(!kyber_depth[i]);</span><br><span class="line">		WARN_ON(!kyber_batch_size[i]);</span><br><span class="line">		ret = sbitmap_queue_init_node(&amp;kqd-&gt;domain_tokens[i],</span><br><span class="line">					      kyber_depth[i], <span class="number">-1</span>, <span class="literal">false</span>,</span><br><span class="line">					      GFP_KERNEL, q-&gt;node);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">				sbitmap_queue_free(&amp;kqd-&gt;domain_tokens[i]);</span><br><span class="line">			<span class="keyword">goto</span> err_buckets;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化总的时延统计和每种队列的时延参考值(kyber_latency_targets)</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KYBER_OTHER; i++) &#123;</span><br><span class="line">		kqd-&gt;domain_p99[i] = <span class="number">-1</span>;</span><br><span class="line">		kqd-&gt;latency_targets[i] = kyber_latency_targets[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shift = kyber_sched_tags_shift(q);</span><br><span class="line">    <span class="comment">// 限制异步IO的带宽为百分之七十五，留百分之二十五给同步IO，防止同步IO被饿死</span></span><br><span class="line">	kqd-&gt;async_depth = (<span class="number">1U</span> &lt;&lt; shift) * KYBER_ASYNC_PERCENT / <span class="number">100U</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kqd;</span><br><span class="line"></span><br><span class="line">err_buckets:</span><br><span class="line">	free_percpu(kqd-&gt;cpu_latency);</span><br><span class="line">err_kqd:</span><br><span class="line">	kfree(kqd);</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="初始化kyber-hctx-data"><a href="#初始化kyber-hctx-data" class="headerlink" title="初始化kyber_hctx_data"></a>初始化kyber_hctx_data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kyber_init_hctx</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="type">unsigned</span> <span class="type">int</span> hctx_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span> =</span> hctx-&gt;<span class="built_in">queue</span>-&gt;elevator-&gt;elevator_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_hctx_data</span> *<span class="title">khd</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">// 申请kyber_hctx_data</span></span><br><span class="line">	khd = kmalloc_node(<span class="keyword">sizeof</span>(*khd), GFP_KERNEL, hctx-&gt;numa_node);</span><br><span class="line">	<span class="keyword">if</span> (!khd)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 申请hctx-&gt;nr_ctx个kyber_ctx_queue(暂存队列)</span></span><br><span class="line">    <span class="comment">// hctx-&gt;nr_ctx就是与硬队列对应的软队列的个数</span></span><br><span class="line">	khd-&gt;kcqs = kmalloc_array_node(hctx-&gt;nr_ctx,</span><br><span class="line">				       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kyber_ctx_queue),</span><br><span class="line">				       GFP_KERNEL, hctx-&gt;numa_node);</span><br><span class="line">	<span class="keyword">if</span> (!khd-&gt;kcqs)</span><br><span class="line">		<span class="keyword">goto</span> err_khd;</span><br><span class="line">	<span class="comment">// 初始化暂存队列</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hctx-&gt;nr_ctx; i++)</span><br><span class="line">		kyber_ctx_queue_init(&amp;khd-&gt;kcqs[i]);</span><br><span class="line">	<span class="comment">// 初始化kcq_map，用来记录暂存队列上是否有IO挂着，如果有当分发队列为空时就从暂存队列将IO都取到分发队列。</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sbitmap_init_node(&amp;khd-&gt;kcq_map[i], hctx-&gt;nr_ctx,</span><br><span class="line">				      ilog2(<span class="number">8</span>), GFP_KERNEL, hctx-&gt;numa_node)) &#123;</span><br><span class="line">			<span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">				sbitmap_free(&amp;khd-&gt;kcq_map[i]);</span><br><span class="line">			<span class="keyword">goto</span> err_kcqs;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;khd-&gt;lock);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化分发队列</span></span><br><span class="line">		INIT_LIST_HEAD(&amp;khd-&gt;rqs[i]);</span><br><span class="line">        <span class="comment">// 初始化token消耗完了时挂起的IO被唤醒的函数</span></span><br><span class="line">		init_waitqueue_func_entry(&amp;khd-&gt;domain_wait[i],</span><br><span class="line">					  kyber_domain_wake);</span><br><span class="line">		khd-&gt;domain_wait[i].private = hctx;</span><br><span class="line">        <span class="comment">// 挂起的IO就挂在这里</span></span><br><span class="line">		INIT_LIST_HEAD(&amp;khd-&gt;domain_wait[i].entry);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;khd-&gt;wait_index[i], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	khd-&gt;cur_domain = <span class="number">0</span>;</span><br><span class="line">	khd-&gt;batching = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	hctx-&gt;sched_data = khd;</span><br><span class="line">	sbitmap_queue_min_shallow_depth(&amp;hctx-&gt;sched_tags-&gt;bitmap_tags,</span><br><span class="line">					kqd-&gt;async_depth);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_kcqs:</span><br><span class="line">	kfree(khd-&gt;kcqs);</span><br><span class="line">err_khd:</span><br><span class="line">	kfree(khd);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="bio合并入kyber"><a href="#bio合并入kyber" class="headerlink" title="bio合并入kyber"></a>bio合并入kyber</h2><p>当一个bio来到块层时，首先看看这个bio是否能够合并到当前已有的request里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">kyber_bio_merge</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="keyword">struct</span> bio *bio)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_hctx_data</span> *<span class="title">khd</span> =</span> hctx-&gt;sched_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ctx</span> *<span class="title">ctx</span> =</span> blk_mq_get_ctx(hctx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="comment">// 根据软队列在硬队列里的下标找到应该合并哪个暂存队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_ctx_queue</span> *<span class="title">kcq</span> =</span> &amp;khd-&gt;kcqs[ctx-&gt;index_hw];</span><br><span class="line">    <span class="comment">// 根据op flag找到是read、write、discard还是other</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sched_domain = kyber_sched_domain(bio-&gt;bi_opf);</span><br><span class="line">    <span class="comment">// 是什么类型的IO就尝试合并到什么类型的暂存队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">rq_list</span> =</span> &amp;kcq-&gt;rq_list[sched_domain];</span><br><span class="line">	<span class="type">bool</span> merged;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;kcq-&gt;lock);</span><br><span class="line">    <span class="comment">// 调用block层通用函数去合并bio到某个request</span></span><br><span class="line">    <span class="comment">// blk_mq_bio_list_merge会从后往前遍历队列，检查8次能否合并</span></span><br><span class="line">	merged = blk_mq_bio_list_merge(hctx-&gt;<span class="built_in">queue</span>, rq_list, bio);</span><br><span class="line">	spin_unlock(&amp;kcq-&gt;lock);</span><br><span class="line">	blk_mq_put_ctx(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="request插入到kyber"><a href="#request插入到kyber" class="headerlink" title="request插入到kyber"></a>request插入到kyber</h2><p>当发现bio并不能合并到已有的request时，根据这个bio生成一个新的request，并且将这个request插入到kyber当前的队列里面。</p>
<p>生成时调用prepare函数进行request的调度器相关的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_prepare_request</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="keyword">struct</span> bio *bio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置token为-1，表示还未分配token</span></span><br><span class="line">	rq_set_domain_token(rq, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入到相应的队列上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_insert_requests</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> list_head *rq_list, <span class="type">bool</span> at_head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_hctx_data</span> *<span class="title">khd</span> =</span> hctx-&gt;sched_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(rq, next, rq_list, queuelist) &#123;</span><br><span class="line">        <span class="comment">// 与bio合并时同理找到sched_domain和kyber_ctx_queue</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> sched_domain = kyber_sched_domain(rq-&gt;cmd_flags);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kyber_ctx_queue</span> *<span class="title">kcq</span> =</span> &amp;khd-&gt;kcqs[rq-&gt;mq_ctx-&gt;index_hw];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span> =</span> &amp;kcq-&gt;rq_list[sched_domain];</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;kcq-&gt;lock);</span><br><span class="line">        <span class="comment">// 将request插入到队列上</span></span><br><span class="line">		<span class="keyword">if</span> (at_head)</span><br><span class="line">			list_move(&amp;rq-&gt;queuelist, head);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			list_move_tail(&amp;rq-&gt;queuelist, head);</span><br><span class="line">        <span class="comment">// 设置bit表示暂存队列上有request</span></span><br><span class="line">		sbitmap_set_bit(&amp;khd-&gt;kcq_map[sched_domain],</span><br><span class="line">				rq-&gt;mq_ctx-&gt;index_hw);</span><br><span class="line">		blk_mq_sched_request_inserted(rq);</span><br><span class="line">		spin_unlock(&amp;kcq-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="kyber分发request"><a href="#kyber分发request" class="headerlink" title="kyber分发request"></a>kyber分发request</h2><p>kyber注册的分发hook为kyber_dispatch_request()函数。kyber采用round robin的方式遍历分发队列的read、write、discard、other队列，选择一个IO分发到硬队列，当分发队列上没有IO时会遍历与这个分发队列相关联的所有暂存队列，将暂存队列上的所有IO都转到分发队列上，然后再看有没有IO可以分发的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> request *<span class="title function_">kyber_dispatch_request</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span> =</span> hctx-&gt;<span class="built_in">queue</span>-&gt;elevator-&gt;elevator_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_hctx_data</span> *<span class="title">khd</span> =</span> hctx-&gt;sched_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;khd-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * First, if we are still entitled to batch, try to dispatch a request</span></span><br><span class="line"><span class="comment">	 * from the batch.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果当前队列派发的IO个数还没有达到最大值则继续派发当前队列的IO</span></span><br><span class="line">	<span class="keyword">if</span> (khd-&gt;batching &lt; kyber_batch_size[khd-&gt;cur_domain]) &#123;</span><br><span class="line">		rq = kyber_dispatch_cur_domain(kqd, khd, hctx);</span><br><span class="line">		<span class="keyword">if</span> (rq)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Either,</span></span><br><span class="line"><span class="comment">	 * 1. We were no longer entitled to a batch.</span></span><br><span class="line"><span class="comment">	 * 2. The domain we were batching didn&#x27;t have any requests.</span></span><br><span class="line"><span class="comment">	 * 3. The domain we were batching was out of tokens.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Start another batch. Note that this wraps back around to the original</span></span><br><span class="line"><span class="comment">	 * domain if no other domains have requests or tokens.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 否则将batching置为0，选择下一个派发的队列，如果当前已经是other队列了，</span></span><br><span class="line">    <span class="comment">// 则跳到第一个的read队列</span></span><br><span class="line">	khd-&gt;batching = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (khd-&gt;cur_domain == KYBER_NUM_DOMAINS - <span class="number">1</span>)</span><br><span class="line">			khd-&gt;cur_domain = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			khd-&gt;cur_domain++;</span><br><span class="line"></span><br><span class="line">		rq = kyber_dispatch_cur_domain(kqd, khd, hctx);</span><br><span class="line">		<span class="keyword">if</span> (rq)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq = <span class="literal">NULL</span>;</span><br><span class="line">out:</span><br><span class="line">	spin_unlock(&amp;khd-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kyber_dispatch_cur_domain()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> request *</span><br><span class="line"><span class="title function_">kyber_dispatch_cur_domain</span><span class="params">(<span class="keyword">struct</span> kyber_queue_data *kqd,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> kyber_hctx_data *khd,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> blk_mq_hw_ctx *hctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">rqs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的分发队列</span></span><br><span class="line">	rqs = &amp;khd-&gt;rqs[khd-&gt;cur_domain];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we already have a flushed request, then we just need to get a</span></span><br><span class="line"><span class="comment">	 * token for it. Otherwise, if there are pending requests in the kcqs,</span></span><br><span class="line"><span class="comment">	 * flush the kcqs, but only if we can get a token. If not, we should</span></span><br><span class="line"><span class="comment">	 * leave the requests in the kcqs so that they can be merged. Note that</span></span><br><span class="line"><span class="comment">	 * khd-&gt;lock serializes the flushes, so if we observed any bit set in</span></span><br><span class="line"><span class="comment">	 * the kcq_map, we will always get a request.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 选择队列里面第一个IO</span></span><br><span class="line">	rq = list_first_entry_or_null(rqs, <span class="keyword">struct</span> request, queuelist);</span><br><span class="line">	<span class="keyword">if</span> (rq) &#123;</span><br><span class="line">        <span class="comment">// 获取token</span></span><br><span class="line">		nr = kyber_get_domain_token(kqd, khd, hctx);</span><br><span class="line">		<span class="keyword">if</span> (nr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取到了token</span></span><br><span class="line">			khd-&gt;batching++;</span><br><span class="line">            <span class="comment">// 将token保存在request的priv字段里面</span></span><br><span class="line">			rq_set_domain_token(rq, nr);</span><br><span class="line">            <span class="comment">// 从分发队列上摘链</span></span><br><span class="line">			list_del_init(&amp;rq-&gt;queuelist);</span><br><span class="line">			<span class="keyword">return</span> rq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			trace_kyber_throttled(kqd-&gt;q,</span><br><span class="line">					      kyber_domain_names[khd-&gt;cur_domain]);</span><br><span class="line">		&#125;</span><br><span class="line">       <span class="comment">// kcq_map的bit位被设置表示当前分发的IO类型在暂存队列是有IO的</span></span><br><span class="line">       <span class="comment">// kcq_map在insert request的时候置的</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sbitmap_any_bit_set(&amp;khd-&gt;kcq_map[khd-&gt;cur_domain])) &#123;</span><br><span class="line">       </span><br><span class="line">		nr = kyber_get_domain_token(kqd, khd, hctx);</span><br><span class="line">		<span class="keyword">if</span> (nr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 暂存队列有IO，并且当前IO类型的token还没有被消耗完</span></span><br><span class="line">            <span class="comment">// 将暂存队列的IO转到分发队列上</span></span><br><span class="line">			kyber_flush_busy_kcqs(khd, khd-&gt;cur_domain, rqs);</span><br><span class="line">            <span class="comment">// IO转到分发队列后肯定能获取到IO进行分发</span></span><br><span class="line">			rq = list_first_entry(rqs, <span class="keyword">struct</span> request, queuelist);</span><br><span class="line">			khd-&gt;batching++;</span><br><span class="line">			rq_set_domain_token(rq, nr);</span><br><span class="line">			list_del_init(&amp;rq-&gt;queuelist);</span><br><span class="line">			<span class="keyword">return</span> rq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			trace_kyber_throttled(kqd-&gt;q,</span><br><span class="line">					      kyber_domain_names[khd-&gt;cur_domain]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There were either no pending requests or no tokens. */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kyber_get_domain_token()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kyber_get_domain_token</span><span class="params">(<span class="keyword">struct</span> kyber_queue_data *kqd,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> kyber_hctx_data *khd,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> blk_mq_hw_ctx *hctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sched_domain = khd-&gt;cur_domain;</span><br><span class="line">    <span class="comment">// 根据当前分发的IO类型找到申请token的sbitmap_queue</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbitmap_queue</span> *<span class="title">domain_tokens</span> =</span> &amp;kqd-&gt;domain_tokens[sched_domain];</span><br><span class="line">    <span class="comment">// 用于将当前分发队列挂到等待队列的结构</span></span><br><span class="line">	<span class="type">wait_queue_entry_t</span> *wait = &amp;khd-&gt;domain_wait[sched_domain];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbq_wait_state</span> *<span class="title">ws</span>;</span></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	<span class="comment">// 从sbitmap_queue获取一个没有在用的token</span></span><br><span class="line">	nr = __sbitmap_queue_get(domain_tokens);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we failed to get a domain token, make sure the hardware queue is</span></span><br><span class="line"><span class="comment">	 * run when one becomes available. Note that this is serialized on</span></span><br><span class="line"><span class="comment">	 * khd-&gt;lock, but we still need to be careful about the waker.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// nr &lt; 0表示没有获取到token，并且当前分发队列没有被挂起</span></span><br><span class="line">	<span class="keyword">if</span> (nr &lt; <span class="number">0</span> &amp;&amp; list_empty_careful(&amp;wait-&gt;entry)) &#123;</span><br><span class="line">		ws = sbq_wait_ptr(domain_tokens,</span><br><span class="line">				  &amp;khd-&gt;wait_index[sched_domain]);</span><br><span class="line">		khd-&gt;domain_ws[sched_domain] = ws;</span><br><span class="line">        <span class="comment">// 将当前的分发队列挂到相应的等待队列</span></span><br><span class="line">		add_wait_queue(&amp;ws-&gt;wait, wait);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Try again in case a token was freed before we got on the wait</span></span><br><span class="line"><span class="comment">		 * queue.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 可能在挂起的时候有IO回来释放了token，在挂起之后再尝试一次看能否获取到token</span></span><br><span class="line">        <span class="comment">// 如果能获取到则从等待队列上取下</span></span><br><span class="line">		nr = __sbitmap_queue_get(domain_tokens);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we got a token while we were on the wait queue, remove ourselves</span></span><br><span class="line"><span class="comment">	 * from the wait queue to ensure that all wake ups make forward</span></span><br><span class="line"><span class="comment">	 * progress. It&#x27;s possible that the waker already deleted the entry</span></span><br><span class="line"><span class="comment">	 * between the !list_empty_careful() check and us grabbing the lock, but</span></span><br><span class="line"><span class="comment">	 * list_del_init() is okay with that.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果获取到了token，并且分发队列是被挂起的</span></span><br><span class="line">	<span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; !list_empty_careful(&amp;wait-&gt;entry)) &#123;</span><br><span class="line">		ws = khd-&gt;domain_ws[sched_domain];</span><br><span class="line">		spin_lock_irq(&amp;ws-&gt;wait.lock);</span><br><span class="line">        <span class="comment">// 将分发队列从等待队列上摘下</span></span><br><span class="line">		list_del_init(&amp;wait-&gt;entry);</span><br><span class="line">		spin_unlock_irq(&amp;ws-&gt;wait.lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kyber_flush_busy_kcqs()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_flush_busy_kcqs</span><span class="params">(<span class="keyword">struct</span> kyber_hctx_data *khd,</span></span><br><span class="line"><span class="params">				  <span class="type">unsigned</span> <span class="type">int</span> sched_domain,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flush_kcq_data</span> <span class="title">data</span> =</span> &#123;</span><br><span class="line">		.khd = khd,</span><br><span class="line">		.sched_domain = sched_domain,</span><br><span class="line">		.<span class="built_in">list</span> = <span class="built_in">list</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 这个函数会遍历当前IO类型的kcq_map的每一个bit，</span></span><br><span class="line">    <span class="comment">// 然后执行flush_busy_kcq函数将暂存队列的IO都摘到分发队列上</span></span><br><span class="line">    <span class="comment">// 我们知道一个bit代表一个跟硬队列对应的CPU核</span></span><br><span class="line">	sbitmap_for_each_set(&amp;khd-&gt;kcq_map[sched_domain],</span><br><span class="line">			     flush_busy_kcq, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitnr就代表是跟硬队列对应的第几个cpu核</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">flush_busy_kcq</span><span class="params">(<span class="keyword">struct</span> sbitmap *sb, <span class="type">unsigned</span> <span class="type">int</span> bitnr, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flush_kcq_data</span> *<span class="title">flush_data</span> =</span> data;</span><br><span class="line">    <span class="comment">// 获取到这个核的暂存队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_ctx_queue</span> *<span class="title">kcq</span> =</span> &amp;flush_data-&gt;khd-&gt;kcqs[bitnr];</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;kcq-&gt;lock);</span><br><span class="line">    <span class="comment">// 将暂存队列的sched_domain IO种类的队列上的IO都摘到分发队列去，</span></span><br><span class="line">    <span class="comment">// sched_domain是kyber_flush_busy_kcqs函数传入的</span></span><br><span class="line">	list_splice_tail_init(&amp;kcq-&gt;rq_list[flush_data-&gt;sched_domain],</span><br><span class="line">			      flush_data-&gt;<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">// 清理到bit位，表示当前这个核的这个IO类型的暂存队列已经没有IO了</span></span><br><span class="line">	sbitmap_clear_bit(sb, bitnr);</span><br><span class="line">	spin_unlock(&amp;kcq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IO结束的时候释放token，同时这也是kyber的requeue操作的hook，重新进入队列要释放掉已经拿到的token。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_finish_request</span><span class="params">(<span class="keyword">struct</span> request *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span> =</span> rq-&gt;q-&gt;elevator-&gt;elevator_data;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 释放掉request的priv字段记录的token</span></span><br><span class="line">	rq_clear_domain_token(kqd, rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rq_clear_domain_token</span><span class="params">(<span class="keyword">struct</span> kyber_queue_data *kqd,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> request *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sched_domain;</span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">	nr = rq_get_domain_token(rq); <span class="comment">// token保存在request的priv字段</span></span><br><span class="line">	<span class="keyword">if</span> (nr != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取IO类型</span></span><br><span class="line">		sched_domain = kyber_sched_domain(rq-&gt;cmd_flags);</span><br><span class="line">        <span class="comment">// 释放token</span></span><br><span class="line">		sbitmap_queue_clear(&amp;kqd-&gt;domain_tokens[sched_domain], nr,</span><br><span class="line">				    rq-&gt;mq_ctx-&gt;cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sbitmap_queue_clear</span><span class="params">(<span class="keyword">struct</span> sbitmap_queue *sbq, <span class="type">unsigned</span> <span class="type">int</span> nr,</span></span><br><span class="line"><span class="params">			 <span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbitmap_clear_bit_unlock(&amp;sbq-&gt;sb, nr); <span class="comment">// 清除bit位</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pairs with the memory barrier in set_current_state() to ensure the</span></span><br><span class="line"><span class="comment">	 * proper ordering of clear_bit_unlock()/waitqueue_active() in the waker</span></span><br><span class="line"><span class="comment">	 * and test_and_set_bit_lock()/prepare_to_wait()/finish_wait() in the</span></span><br><span class="line"><span class="comment">	 * waiter. See the comment on waitqueue_active().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_mb__after_atomic();</span><br><span class="line">	sbitmap_queue_wake_up(sbq); <span class="comment">// 唤醒分发队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!sbq-&gt;round_robin &amp;&amp; nr &lt; sbq-&gt;sb.depth))</span><br><span class="line">		*per_cpu_ptr(sbq-&gt;alloc_hint, cpu) = nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒动作会调用在初始化流程注册的kyber_domain_wake()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kyber_domain_wake</span><span class="params">(<span class="type">wait_queue_entry_t</span> *wait, <span class="type">unsigned</span> mode, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">			     <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_hw_ctx</span> *<span class="title">hctx</span> =</span> READ_ONCE(wait-&gt;private);</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;wait-&gt;entry); <span class="comment">// 移出等待队列</span></span><br><span class="line">	blk_mq_run_hw_queue(hctx, <span class="literal">true</span>); <span class="comment">// 执行run_hw_queue函数，去分发IO</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="request完成"><a href="#request完成" class="headerlink" title="request完成"></a>request完成</h2><p>IO从设备驱动回到block层的时候会调用kyber调度器注册的hook–completed_request即kyber_completed_request()函数，在完成函数里面统计IO的时延以调整token数量。</p>
<p>kyber会统计两种时延：</p>
<p>KYBER_TOTAL_LATENCY：表示IO在kernel里的时延，即总的时延。</p>
<p>KYBER_IO_LATENCY：表示IO在设备上的执行时延。</p>
<p>kyber_cpu_latency：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* buckets是一个atomic_t的三维数组，第一维表示要统计的IO类型，第二维表示是KYBER_TOTAL_LATENCY还是KYBER_IO_LATENCY，第三维表示的是8个IO时延相对于参考值的倍数的桶，先将时延统计到per_cpu的kyber_cpu_latency中，然后通过timer将所有cpu的统计加起来，通过一定的算法调整token数。 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	KYBER_LATENCY_BUCKETS: 值为8，表示个桶，前KYBER_GOOD_BUCKETS(4)个桶表示“GOOD”的时延，后面4个表示“BAD”的时延。</span></span><br><span class="line"><span class="comment">	GOOD时延表示IO时延小于等于时延参考值。</span></span><br><span class="line"><span class="comment">	BAD时延表示IO时延大于时延参考值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kyber_cpu_latency</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> buckets[KYBER_OTHER][<span class="number">2</span>][KYBER_LATENCY_BUCKETS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_completed_request</span><span class="params">(<span class="keyword">struct</span> request *rq, u64 now)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span> =</span> rq-&gt;q-&gt;elevator-&gt;elevator_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_cpu_latency</span> *<span class="title">cpu_latency</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sched_domain;</span><br><span class="line">	u64 target;</span><br><span class="line">	<span class="comment">// 获取完成的IO的类型</span></span><br><span class="line">	sched_domain = kyber_sched_domain(rq-&gt;cmd_flags);</span><br><span class="line">    <span class="comment">// other类型的IO不会统计时延，自然也不会去调整其token数量</span></span><br><span class="line">	<span class="keyword">if</span> (sched_domain == KYBER_OTHER)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// cpu_latency延迟统计是per_cpu的，这里获取当前CPU的指针，将IO的时延统计到当前CPU</span></span><br><span class="line">	cpu_latency = get_cpu_ptr(kqd-&gt;cpu_latency);</span><br><span class="line">    <span class="comment">// 当前IO的类型的延迟参考值</span></span><br><span class="line">	target = kqd-&gt;latency_targets[sched_domain];</span><br><span class="line">    <span class="comment">// 统计总的IO时延，与下面对比，now减去的起始时间不一样的</span></span><br><span class="line">	add_latency_sample(cpu_latency, sched_domain, KYBER_TOTAL_LATENCY,</span><br><span class="line">			   target, now - rq-&gt;start_time_ns);</span><br><span class="line">    <span class="comment">// 统计IO在设备上的时延</span></span><br><span class="line">	add_latency_sample(cpu_latency, sched_domain, KYBER_IO_LATENCY, target,</span><br><span class="line">			   now - rq-&gt;io_start_time_ns);</span><br><span class="line">	put_cpu_ptr(kqd-&gt;cpu_latency);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 减小timer的到期时间</span></span><br><span class="line">	timer_reduce(&amp;kqd-&gt;timer, jiffies + HZ / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add_latency_sample()统计函数，kyber会统计当前IO的时延相对于参考时延的倍数（0~7倍），然后将这个倍数的计数记录在per_cpu的kyber_cpu_latency中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_latency_sample</span><span class="params">(<span class="keyword">struct</span> kyber_cpu_latency *cpu_latency,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> <span class="type">int</span> sched_domain, <span class="type">unsigned</span> <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">			       u64 target, u64 latency)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bucket;</span><br><span class="line">	u64 divisor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (latency &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里将参考值除以4，计算所得的bucket表示时延是</span></span><br><span class="line">        <span class="comment">// &lt;= 1/4 * 时延参考值</span></span><br><span class="line">        <span class="comment">// &lt;= 1/2 * 时延参考值</span></span><br><span class="line">        <span class="comment">// &lt;= 3/4 * 时延参考值</span></span><br><span class="line">        <span class="comment">// &lt;= 时延参考值</span></span><br><span class="line">        <span class="comment">// &lt;= (1 + 1/4) * 时延参考值</span></span><br><span class="line">        <span class="comment">// &lt;= (1 + 1/2) * 时延参考值</span></span><br><span class="line">        <span class="comment">// &lt;= (1 + 3/4) * 时延参考值</span></span><br><span class="line">        <span class="comment">// &gt; 3/4 * 时延参考值</span></span><br><span class="line">		divisor = <span class="type">max_t</span>(u64, target &gt;&gt; KYBER_LATENCY_SHIFT, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 这里将latency减去1，除法所得的值可以准确的落入buckets的下标里面，因为数组下标是从0开始的。 </span></span><br><span class="line">        <span class="comment">// 如果时延过大，除法所得的值超过了7，则约束其到7，这里取一个最小值</span></span><br><span class="line">        <span class="comment">// 大家可以假设一些值来计算一下。</span></span><br><span class="line">		bucket = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, div64_u64(latency - <span class="number">1</span>, divisor),</span><br><span class="line">			       KYBER_LATENCY_BUCKETS - <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bucket = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 增加相应的桶的计数</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;cpu_latency-&gt;buckets[sched_domain][type][bucket]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="根据时延统计调整token数"><a href="#根据时延统计调整token数" class="headerlink" title="根据时延统计调整token数"></a>根据时延统计调整token数</h2><p>在初始化流程的kyber_queue_data_alloc()函数初始化了一个timer，timer每隔一段时间会执行来动态调整token数量，执行的函数为kyber_timer_fn()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_timer_fn</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span> =</span> from_timer(kqd, t, timer);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sched_domain;</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line">	<span class="type">bool</span> bad = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sum all of the per-cpu latency histograms. */</span></span><br><span class="line">    <span class="comment">// 将per_cpu的统计信息合并到kyber_queue_data的latency_buckets里面</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kyber_cpu_latency</span> *<span class="title">cpu_latency</span>;</span></span><br><span class="line"></span><br><span class="line">		cpu_latency = per_cpu_ptr(kqd-&gt;cpu_latency, cpu);</span><br><span class="line">		<span class="keyword">for</span> (sched_domain = <span class="number">0</span>; sched_domain &lt; KYBER_OTHER; sched_domain++) &#123;</span><br><span class="line">			flush_latency_buckets(kqd, cpu_latency, sched_domain,</span><br><span class="line">					      KYBER_TOTAL_LATENCY);</span><br><span class="line">			flush_latency_buckets(kqd, cpu_latency, sched_domain,</span><br><span class="line">					      KYBER_IO_LATENCY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check if any domains have a high I/O latency, which might indicate</span></span><br><span class="line"><span class="comment">	 * congestion in the device. Note that we use the p90; we don&#x27;t want to</span></span><br><span class="line"><span class="comment">	 * be too sensitive to outliers here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 看IO在设备上的时延是否是BAD的</span></span><br><span class="line">	<span class="keyword">for</span> (sched_domain = <span class="number">0</span>; sched_domain &lt; KYBER_OTHER; sched_domain++) &#123;</span><br><span class="line">		<span class="type">int</span> p90;</span><br><span class="line"></span><br><span class="line">		p90 = calculate_percentile(kqd, sched_domain, KYBER_IO_LATENCY,</span><br><span class="line">					   <span class="number">90</span>);</span><br><span class="line">		<span class="keyword">if</span> (p90 &gt;= KYBER_GOOD_BUCKETS)</span><br><span class="line">			bad = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Adjust the scheduling domain depths. If we determined that there was</span></span><br><span class="line"><span class="comment">	 * congestion, we throttle all domains with good latencies. Either way,</span></span><br><span class="line"><span class="comment">	 * we ease up on throttling domains with bad latencies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (sched_domain = <span class="number">0</span>; sched_domain &lt; KYBER_OTHER; sched_domain++) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> orig_depth, depth;</span><br><span class="line">		<span class="type">int</span> p99;</span><br><span class="line"></span><br><span class="line">		p99 = calculate_percentile(kqd, sched_domain,</span><br><span class="line">					   KYBER_TOTAL_LATENCY, <span class="number">99</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This is kind of subtle: different domains will not</span></span><br><span class="line"><span class="comment">		 * necessarily have enough samples to calculate the latency</span></span><br><span class="line"><span class="comment">		 * percentiles during the same window, so we have to remember</span></span><br><span class="line"><span class="comment">		 * the p99 for the next time we observe congestion; once we do,</span></span><br><span class="line"><span class="comment">		 * we don&#x27;t want to throttle again until we get more data, so we</span></span><br><span class="line"><span class="comment">		 * reset it to -1.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (bad) &#123;</span><br><span class="line">            <span class="comment">// 当前的样本数不够或者timer的时间不够1s，则返回的p99 &lt; 0</span></span><br><span class="line">            <span class="comment">// 采用上一次timer计算所得的p99</span></span><br><span class="line">			<span class="keyword">if</span> (p99 &lt; <span class="number">0</span>)</span><br><span class="line">				p99 = kqd-&gt;domain_p99[sched_domain];</span><br><span class="line">			kqd-&gt;domain_p99[sched_domain] = <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p99 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录这一次计算的p99，下一次timer可能用到</span></span><br><span class="line">			kqd-&gt;domain_p99[sched_domain] = p99;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p99 &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If this domain has bad latency, throttle less. Otherwise,</span></span><br><span class="line"><span class="comment">		 * throttle more iff we determined that there is congestion.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The new depth is scaled linearly with the p99 latency vs the</span></span><br><span class="line"><span class="comment">		 * latency target. E.g., if the p99 is 3/4 of the target, then</span></span><br><span class="line"><span class="comment">		 * we throttle down to 3/4 of the current depth, and if the p99</span></span><br><span class="line"><span class="comment">		 * is 2x the target, then we double the depth.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">         <span class="comment">// 根据总的IO时延统计动态调整token数量的算法比较的“启发式”，也就是根据测试结果和经验来判断应该怎样去调整token的数量</span></span><br><span class="line">		<span class="keyword">if</span> (bad || p99 &gt;= KYBER_GOOD_BUCKETS) &#123;</span><br><span class="line">			orig_depth = kqd-&gt;domain_tokens[sched_domain].sb.depth;</span><br><span class="line">			depth = (orig_depth * (p99 + <span class="number">1</span>)) &gt;&gt; KYBER_LATENCY_SHIFT;</span><br><span class="line">			kyber_resize_domain(kqd, sched_domain, depth);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据统计的时延计算时延的“好坏”</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_percentile</span><span class="params">(<span class="keyword">struct</span> kyber_queue_data *kqd,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> sched_domain, <span class="type">unsigned</span> <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> percentile)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *buckets = kqd-&gt;latency_buckets[sched_domain][type];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bucket, samples = <span class="number">0</span>, percentile_samples;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (bucket = <span class="number">0</span>; bucket &lt; KYBER_LATENCY_BUCKETS; bucket++)</span><br><span class="line">		samples += buckets[bucket];</span><br><span class="line">	<span class="comment">// 没有样本，表明这段时间没有IO</span></span><br><span class="line">	<span class="keyword">if</span> (!samples)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We do the calculation once we have 500 samples or one second passes</span></span><br><span class="line"><span class="comment">	 * since the first sample was recorded, whichever comes first.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 记录超时时间为1s</span></span><br><span class="line">	<span class="keyword">if</span> (!kqd-&gt;latency_timeout[sched_domain])</span><br><span class="line">		kqd-&gt;latency_timeout[sched_domain] = max(jiffies + HZ, <span class="number">1UL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (samples &lt; <span class="number">500</span> &amp;&amp;</span><br><span class="line">	    time_is_after_jiffies(kqd-&gt;latency_timeout[sched_domain])) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	kqd-&gt;latency_timeout[sched_domain] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 找到最能代表延迟情况的那个bucket，</span></span><br><span class="line">    <span class="comment">// 至于这里的算法以及为什么要先计算一个百分比就不清楚了，代码能看懂但却不知为什么。</span></span><br><span class="line">	percentile_samples = DIV_ROUND_UP(samples * percentile, <span class="number">100</span>);</span><br><span class="line">	<span class="keyword">for</span> (bucket = <span class="number">0</span>; bucket &lt; KYBER_LATENCY_BUCKETS - <span class="number">1</span>; bucket++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (buckets[bucket] &gt;= percentile_samples)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		percentile_samples -= buckets[bucket];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(buckets, <span class="number">0</span>, <span class="keyword">sizeof</span>(kqd-&gt;latency_buckets[sched_domain][type]));</span><br><span class="line"></span><br><span class="line">	trace_kyber_latency(kqd-&gt;q, kyber_domain_names[sched_domain],</span><br><span class="line">			    kyber_latency_type_names[type], percentile,</span><br><span class="line">			    bucket + <span class="number">1</span>, <span class="number">1</span> &lt;&lt; KYBER_LATENCY_SHIFT, samples);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bucket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_resize_domain</span><span class="params">(<span class="keyword">struct</span> kyber_queue_data *kqd,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> sched_domain, <span class="type">unsigned</span> <span class="type">int</span> depth)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 新的token数量不会大于最初的初始化值，也不会为0</span></span><br><span class="line">	depth = clamp(depth, <span class="number">1U</span>, kyber_depth[sched_domain]);</span><br><span class="line">	<span class="keyword">if</span> (depth != kqd-&gt;domain_tokens[sched_domain].sb.depth) &#123;</span><br><span class="line">		sbitmap_queue_resize(&amp;kqd-&gt;domain_tokens[sched_domain], depth);</span><br><span class="line">		trace_kyber_adjust(kqd-&gt;q, kyber_domain_names[sched_domain],</span><br><span class="line">				   depth);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="kyber退出"><a href="#kyber退出" class="headerlink" title="kyber退出"></a>kyber退出</h2><p>kyber退出的时候有两个hook函数需要执行，kyber_exit_sched()和kyber_exit_hctx()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_exit_hctx</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx, <span class="type">unsigned</span> <span class="type">int</span> hctx_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_hctx_data</span> *<span class="title">khd</span> =</span> hctx-&gt;sched_data;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++)</span><br><span class="line">		sbitmap_free(&amp;khd-&gt;kcq_map[i]);</span><br><span class="line">	kfree(khd-&gt;kcqs);</span><br><span class="line">	kfree(hctx-&gt;sched_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kyber_exit_sched</span><span class="params">(<span class="keyword">struct</span> elevator_queue *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kyber_queue_data</span> *<span class="title">kqd</span> =</span> e-&gt;elevator_data;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	del_timer_sync(&amp;kqd-&gt;timer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KYBER_NUM_DOMAINS; i++)</span><br><span class="line">		sbitmap_queue_free(&amp;kqd-&gt;domain_tokens[i]);</span><br><span class="line">	free_percpu(kqd-&gt;cpu_latency);</span><br><span class="line">	kfree(kqd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放掉timer和所有初始化时申请的内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kyber调度器是一个适合于高速存储介质(如NVMe)的IO调度器，文章对其做了机制介绍和源码分析，关于根据时延统计动态调整token数目的部分还未弄懂开发者的用意，算是这篇文章的一个遗憾，如果有知道的大佬还请不吝赐教。</p>
<p>另外mq-deadline调度器和bfq调度器的分析文章也在撰写中，bfq比kyber复杂的很多（仅从代码量上看就能大概推断），因此可能需要一些时间理解代码，mq-deadline调度器则会尽快呈现。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/olunx/topics/1559753">https://www.dazhuanlan.com/olunx/topics/1559753</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://example.com">Cahir</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://example.com/2023/10/21/kyber/kyber/">http://example.com/2023/10/21/kyber/kyber/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/block/">block</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2023/10/21/mq-deadline/mq-deadline/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">mq-deadline调度器原理及源码分析</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:liugx@7140@163.com" class="iconfont icon-email" title="email"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Cahir</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.2"></script>
</body>
</html>
